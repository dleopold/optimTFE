% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimTFE.R
\name{optimTFE}
\alias{optimTFE}
\title{optimTFE algorithm}
\usage{
optimTFE(
  dir = ".",
  targets_in = optimTFE::example_targets,
  suitability_in = optimTFE::example_spp_suitability,
  sub_regions_file = NULL,
  populations_file = NULL,
  min_spp_suit_score = 0,
  max_candidate_units = Inf,
  rand_tolerance = 5,
  max_spp_selected = Inf,
  single_pu_pop = TRUE,
  n = 100,
  cores = NULL,
  progress = TRUE,
  batch_size = NULL,
  max_batch_size = 1000,
  min_batch_size = 10,
  seed = NULL,
  output_dir = NULL,
  output_prefix = "solutions",
  output_csv = TRUE,
  output_parquet = FALSE,
  force_overwrite = FALSE,
  delete_tmp_files = TRUE,
  return_df = FALSE
)
}
\arguments{
\item{dir}{working directory}

\item{targets_in}{Species targets file - path to a csv file or a pre-loaded
data frame. First 2 columns should be species names and total targets
populations, respectively. Additional columns must be provided when using
sub-region targets. Column names must match the sub-region names provided
in the `sub_regions_file` input and values should be the minimum number of
populations required in the sub-region.}

\item{suitability_in}{Species suitability matrix - path to a csv file or a
pre-loaded data frame. The first column must be the planning unit id /
number and following columns are species. Values indicate the suitability
scores for each species / taxon in each planning unit.}

\item{sub_regions_file}{(optional) A .csv input defining sub-regions within
the set of planning units. Must include 1 row for each planning unit with
binary values indicating the sub-region membership of each planning unit.
Sub-region column names must match those in the `targets_in`.}

\item{populations_file}{(optional) A .csv input matrix of delineated
populations. Row / column names must match suitability matrix.}

\item{min_spp_suit_score}{minimum suitability score for a species to be
considered in a location (default = 0)}

\item{max_candidate_units}{maximum number of candidate units to consider for
a species at each round of selection (default = Inf). This will subset
species data by highest suitability score to the number of units listed,
but will not exclude known populations.}

\item{rand_tolerance}{the range of species richness, from maximum, to
consider for selection at each iteration(default = 5)}

\item{max_spp_selected}{maximum number of species to select in each location
(default = Inf) to reduce 'species packing' within units. This parameter
could cause species to be unable to meet targets.}

\item{single_pu_pop}{only one location (ie unit) selected per delineated
population (only when prioritize_known_pops = TRUE)}

\item{n}{number of solutions to generate}

\item{cores}{number of cores to use (default = all available)}

\item{progress}{show progress bar}

\item{batch_size}{when parallel processing is used, this parameter can be
used to process solution in batches for improved efficiency (default =
NULL). If not provided (NULL), batch size will be calculated automatically
as `ceiling(n/(cores*4))`.}

\item{max_batch_size}{limit batch size for parallel processing (default =
1000). Smaller values will allow the progress bar to update more
frequently, but at the cost of more disk writes.}

\item{min_batch_size}{default = 10.}

\item{seed}{seed for reproducible output (optional)}

\item{output_dir}{location to write outputs (default = `file.path(dir,
'output')`). Created for user if does not exist.}

\item{output_prefix}{prefix for output files (default = 'solutions')}

\item{output_csv}{Should the solutions be written to a single csv file
(default = TRUE)}

\item{output_parquet}{Should the solutions be written to a parquet file
(default = FALSE)}

\item{force_overwrite}{overwrite existing output files (default = FALSE)}

\item{delete_tmp_files}{should temporary files be deleted after processing
(default = TRUE)}

\item{return_df}{return all generated solutions as a data frame (default =
FALSE)}
}
\description{
Generate a suite of conservation footprint 'solutions' based on feature
suitability values and a list of targets for all features.
}
\details{
The function generates conservation footprints based on species/feature
habitat suitability scores within planning units, and a target number of
populations per species. A greedy algorithm iteratively selects planning
units with the highest number of remaining species targets until all targets
are met. To mitigate known pitfalls of richness-based selection at each
iteration, stochasticity is introduced where one planning unit is randomly
selected from a pool of planning units within a set number of targets of the
maximum for that iteration. To maximize species suitability scores in
selected units the probability of selection is weighted by the mean
suitability scores of remaining targets. Constraints, such as hybridization,
can be introduced to specifically prohibit the algorithm from selecting the
same planning unit for two taxa. This process is then repeated to generate
many spatially efficient solutions that meet all targets for each species.
}
