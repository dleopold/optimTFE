---
title: "optimTFE:
Create conservation footprints and generate summary data"
author: "Christina Leopold"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{optimTFE:
Create conservation footprints and generate summary data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

* This vignette will show you how to bring in data for use in the optimTFE
algorithm to generate conservation solutions.
It will then provide examples of how to generate relevant summary statistics in 
order to explore solutions and tradeoffs.
* It will also demonstrate how to generate an interactive leaflet application 
for visually exploring solutions.

First, we will attach the packages needed for the example. Then we will use a
sample dataset to generate input files needed for the optimTFE algorithm and
subsequent output explorations.

```{r setup, echo=FALSE}
knitr::opts_chunk$set(warning = FALSE)
library(dplyr)
library(ggplot2)
library(htmltools)
library(htmlwidgets)
library(leaflet)
library(leaflet.providers)
library(optimTFE)
library(rmarkdown)
library(sf)
library(tidyr)
library(tidyverse)
```

Now we will bring in our file with species suitability values by planning unit.
Here our example is with a spatial dataset and we need to create a .csv.
The .csv file should include ONLY the planning unit column (first), and then
species suitability values for each species/feature for each unit,
e.g. sp_01, sp_01, etc. Ensure you also have a .csv with species targets, and
other input files as desired.

```{r species suitabtility}
knitr::opts_chunk$set(warning = TRUE, echo = TRUE)
#  first we'll setup a filepath to reference as we save files; likely your
# project folder:
path <- "C:/optimTFE"
# Here we have created tempdir() for calling output files later; likely best to keep
# in the project folder when running analysis. This is for the tutorial example.
dir <- gsub("\\\\", "/", tempdir())

spp_suit <- optimTFE::units_spp_suit
spp_suit_df <- spp_suit |>
  as.data.frame() |>
  dplyr::select(-geom)
#  relocate planning unit column to be first if needed

# write the species suitability file as a .csv and save to your local directory
# EXAMPLE:
# write.csv(spp_suit_df, file = file.path(dir, "spp_suitability.csv"), row.names = FALSE)
```
## Generate solutions

We are ready to run the optimization algorithm.
This example uses an existing species suitability file. Examine these example datasets
to understand how to setup algorithm inputs.
Input files must be in .csv format; supply filepaths.
```{r Run optimization, warning=TRUE, echo=TRUE}

# simple optimization with only suitability values and targets, without
# subregion targets. Random tolerance is set to 5, and clipped to include
# only units for a given species if the suitability value is >= 0.1.

sample_sols100 <- optimTFE(
                  dir = tempdir(),
                  spp_targets_fn = system.file("extdata", "targets.csv", package = "optimTFE"),
                  spp_suit_fn = system.file("extdata", "spp_suitability.csv", package = "optimTFE"),
                  rand_tolerance = 5,
                  min_spp_suit_score = 0.1,
                  n = 100,
                  cores = 6,
                  output_csv = T,
                  return_df = T) # return data.frame as object, named above

```

Take a look at the solutions output. Note that the first column is named
unit_id. The select_order column indicates the order in which a planning unit
was selected for the solution. Species columns indicate whether a unit was
selected for (1) within a given unit_id.
```{r view solutions}
head(sample_sols100, 5)
```
## Generate summary information

The rest of vignette provides examples of exploring the solutions dataset through
summary statistics and inclusion of associated spatial data.
If >100,000 solutions were generated, and depending on your computer RAM, you may want to subset solutions before creating many summary statistics.

If you did not save the solutions output as an object, read in now.
The file location is printed in the console after running the algorithm:
'Saving csv output: C:\...'

```{r Solution summary statistics, echo=TRUE, fig.width=8.25, fig.height=6, fig.show='asis'}
# read in solution output
# sample_sols100 <- read.csv(file.path(dir, "output", "solutions.csv"))

# get planning unit count for each solution
sols_unit_ct <- solutions_unit_ct(sample_sols100)

# find solutions with minimum unit counts
min_PU_ct <- min(sols_unit_ct$PU_ct)
print(sols_unit_ct[sols_unit_ct$PU_ct == min_PU_ct, ])

# bring in spatial data
# read in spatial data with PU id's and background files
pu_data <- optimTFE::units_spp_suit
pu_data <- pu_data |>
  select(-c(2:37))
# plot(pu_data) - eastern portion of Maui Island

# Return a dataframe of unit count frequencies
PU_ct_freq <- all_solutions_freq(sols_unit_ct)

# make a distribution plot of PU_counts
plot_solutions_freq(PU_ct_freq)

```
Now we can take a look at a map of the planning unit count frequencies across all solutions.

```{r Plot frequency of planning units across all solutions, echo=TRUE, fig.width=8.25, fig.height=6, fig.show='asis'}
pu_ct_freq_map(solution_output = sample_sols100 , pu_spatial_data = pu_data)
```

Next we may want to plot a single solution. Here we will plot one with a minimum
planning unit count, and identify a solution from the sols_unit_ct object generated
using the solutions_unit_ct function.
Note, the solution number here will be different from ones generated in future examples.

```{r Plot single solution, fig.width=8.25, fig.height=6, fig.show='asis'}
# Assign solution_number; optional.
solution_number <- 44
map_sol_44 <- single_solution_map(solution_number, sample_sols100, pu_data)
```

Next let's generate habitat suitability values for each species within a given solution.
Conservation practitioners may prefer a larger footprint than a minimum size if it
yields habitat more suited to species to be recovered.
Now we can explore this tradeoff.
We will again use the optimTFE solutions output as well as the solution number of
interest, and the metadata filepath.
This function calculates one solution at a time, as it could be computationally 
consuming with >10,000 solutions. (And we create them collectively as part of another evaluation
tool later.)

```{r Get suitability values for input features for a given solution, echo=FALSE}
# You must read in the solutions file as a data.frame; solution number is the solution to evaluate; meta_filepath is the filepath to the solutions.meta file.
 # All 0s are NAs unless you convert them.

# Again I will use solution 44 as an example:
sol44_suit_values <- solution_suit_values(44, sample_sols100, file.path(dir, "output", "solutions.meta"))


```
Next let's get the suitability values for features that were selected for within a given planning unit.
For example, the solution output file shows 1s and 0s for each planning unit for each feature. We will calculate
suitability only for the 1s. 
In contrast, the previous calculation gave the suitability across all species that had suitability values
> 0.

The first input comes from the output of solution_suit_values, here it is sol44. If you do not want to use that input, your input dataframe must include the unit_id column first, and remaining columns are the feature columns with 1s and 0s from the solution output file.

```{r Generate species suitability list for target units only}
sol44_selected_spp_suit <- selected_spp_suit(solution_number, sample_sols100, file.path(dir, "output", "solutions.meta"))
```
Now let's generate some metrics about solutions so we can compare.
We will read-in .shp or .gpkg file with unit_id as the first column and the rest
have metrics of interest for selecting a solution. For example, this dataset has 
area_km2 because units are not uniform, percent of unit within an existing conservation
reserve, percent of unit considered 'good' quality habitat, etc.

You will need to determine how to summarize your data, and provided below is an example.
Then functions are provided to generate visuals for tradeoff evaluations.

```{r Setup dataset and create a solution summary with selection metrics}
# The all_sols_metrics object created is used in the optimTFE.explorer tool.
# read in variables that are aggregated at the unit_id level; again, unit_id must
# be the first column.

PU_metrics <- read_sf(system.file("extdata", "targets.csv", package = "optimTFE"))
# get rid of any unneccessary columns and keep track of order/naming

# Merge to get all summary data and solution info, and spatial data. This could get
# big,so you may want to subset based on footprint unit count, etc.

# Keep unit_id and solution as columns 1 and 2, and columns for getting summary stats 
# (area, conservation lands, etc.)

sample_sols100_metrics <- left_join(PU_metrics, sample_sols100, by = c("PU_num" = "unit_id"))
# renaming so we can pull spatial data later if desired
sample_sols100_metrics_df <- as.data.frame(sample_sols100_metrics) |>
  relocate(solution, .after = PU_num) |>
  select(-c(select_order, geom))
# confirm no geometry or geom column

# Make a new df, summarized by solution number. Get solution-level metrics:
# example of creating summary metrics:
all_sols_metrics <- sample_sols100_metrics_df |>
  filter(!is.na(solution)) |> #some units do not occur in any solution
  group_by(solution) |>
  summarise(
    total_area_kmsq = sum(area_km2, na.rm = TRUE), # total footprint area
    good_hab_mean_pct = (sum(good_hab_kmsq, na.rm = TRUE) / sum(area_km2, na.rm 
          = TRUE)) * 100, #mean percent of footprint with 'good' habitat
    area_unfenced_mean_pct = (sum(not_fenced_kmsq, na.rm = TRUE) / sum(area_km2,
          na.rm = TRUE)) * 100, #mean percent of footprint unfenced
    area_fenced_mean_pct = (sum(fenced_kmsq, na.rm = TRUE) / sum(area_km2,
          na.rm = TRUE)) * 100,
    cons_lands_mean_pct = (sum(reserved_kmsq, na.rm = TRUE) / sum(area_km2, na.rm 
          = TRUE)) * 100,
    FB_richness_max_mean = mean(max_FB_richness, na.rm = TRUE),
    accessibility_max_mean = mean(max_accessibility, na.rm = TRUE)
  )
# Export as .csv for creating the optimTFE.explorer tool later. This is the column
# structure needed as input! 

write.csv(all_sols_metrics, file.path(path, "sample_sols100_metrics.csv" ))

# Now we will calculate solutions with minimum and maximum values across each metric
# First, define which columns are metrics
sol_metrics <- names(all_sols_metrics[2:8])
# Then run metrics_top_solutions function to generate dateframe with min, max, or both
# for each metric across all solutions
max_sol_calcs <- metrics_top_solutions(all_sols_metrics, sol_metrics, summary_type = max)
min_sol_calcs <- metrics_top_solutions(all_sols_metrics, sol_metrics, summary_type = min)

```

Plot a solution and show where the solution falls compared to the rest of the values
across all solutions, and the top 10% of all solutions.

```{r Plot distribution of solutions across metrics compared to a single solution, echo=FALSE, fig.width=8.25, fig.height=6, fig.show='asis'}
# 53 has smallest footprint in this round of solutions, so we will see how it does compared to other solutions for the percent of the footprint with 'good habitat'
# We will use the dataframe generated above with metrics for each solution (all_sols_metrics)

plot_my_metric <- plot_solution_metric(2, all_sols_metrics, "good_hab_mean_pct", 0.9)
plot_my_metric
```
