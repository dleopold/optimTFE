---
title: "optimTFE: Create conservation footprints and generate summary data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{optimTFE: Create conservation footprints and generate summary data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy()
```
### Introduction
The optimTFE package is a spatial conservation prioritization (SCP) tool created to help conservation
managers identify priority recovery areas, represented by planning units, for species 
recovery planning efforts.  

This vignette will demonstrate how to bring in data for use in the optimTFE algorithm
to generate conservation solutions, which we refer to as conservation footprints.
It will then provide examples of how to generate relevant summary statistics in 
order to explore conservation footprints and tradeoffs.  

We also provide a vignette ("Explore_footprints") demonstrating how to visually explore metrics of interest
across generated footprints using an interactive tool. Another vignette ("Footprint_map.html") demonstrates
how to generate an interactive leaflet application for visually exploring species-specific
and planning unit specific qualities of a conservation footprint.

First, we will set a project directory and attach the packages needed for the example.
Then we will use a sample dataset to generate input files needed for the optimTFE
algorithm and subsequent output exploration.
```{r setup, echo=TRUE, warning = FALSE, message=FALSE}
# Set directory
project_dir <- "optimTFE_project"

# Load packages
library(dplyr)
library(ggplot2)
library(htmltools)
library(htmlwidgets)
library(leaflet)
library(leaflet.providers)
library(optimTFE)
library(rmarkdown)
library(sf)
library(tidyr)
library(tidyverse)
```
```{r hidden unlink project dir RE output folder errors, echo=FALSE}
unlink(file.path(project_dir, "output"), recursive = TRUE)
```
Now we will bring in our file with species suitability values by planning unit.
Here our example is with a spatial vector dataset and we need to create a .csv.  
The .csv file should include ONLY the planning unit (PU) column **first**, and then
species suitability values for each species/feature for each unit,
e.g. sp_01, sp_02, etc. Ensure there is also a .csv with species targets (i.e., the number of desired PU targets per species), and
other input files as desired.

```{r species suitabtility}
spp_suit <- optimTFE::units_spp_suit
spp_suit_df <- spp_suit |>
  as.data.frame() |>
  dplyr::select(-geom)
# View(spp_suit_df)
# relocate planning unit column to be first,  if needed
# spp_suit_df <- spp_suit_df |>
#                 relocate("PU_num")
# write the species suitability file as a .csv and save:
# write.csv(spp_suit_df, file = "spp_suitability.csv", row.names = FALSE)
```
#### Generate conservation footprints
We are ready to run the optimization algorithm.  
This example uses existing species suitability and target files. Examine these datasets
to understand how to setup algorithm inputs; these are similar to other SCP tools.  
Input files must be in .csv format. Supply filepaths in the algorithm function.  
The console will print statements or errors related to the optimization run.
```{r Run optimization, echo=TRUE, cache=F}
# Simple optimization with only suitability values and targets, without
# subregion targets. Number of iterations = 100. Random tolerance is set to 5,
# includes only units for a given species if the suitability score value is >= 0.1.
# Note that we call the saved spp_suitability.csv created above.
sample_sols100 <- optimTFE(
                  dir = project_dir,
                  spp_targets_fn = system.file("extdata", "targets.csv", package = "optimTFE"),
                  spp_suit_fn = system.file("extdata", "spp_suitability.csv", package = "optimTFE"),
                  rand_tolerance = 5,
                  min_spp_suit_score = 0.1,
                  n = 100,
                  cores = 6,
                  output_csv = T,
                  return_df = T) # return data.frame as object, named above

```

Take a look at the solutions.csv output. Note that the first column is named
unit_id. The select_order column indicates the order in which a planning unit
was selected for the footprint. Species columns indicate whether a unit was
selected for (1) within a given unit_id.
```{r view footprints}
head(sample_sols100, 5)
```
#### Generate summary information

The rest of the vignette explores the solutions dataset through summary statistics and
inclusion of associated spatial data.  
If >100,000 solutions were generated, and depending on available computing resources, subsetting
before creating many summary statistics will reduce run time.  
If you saved the solutions output to disk, read it in now.   
The file location is printed in the console after running the algorithm:
'Saving csv output: C:\...'
In this vignette, the optimization output was also saved as an r object above (sample_sols100).

```{r Footprint summary statistics, echo=TRUE, fig.width=8.25, fig.height=6, fig.show='asis'}
# Read in solution output if not already in environment
# sample_sols100 <- read.csv(file.path(project_dir, "output", "solutions.csv"))

# Create a dataframe of number of unique solutions
unique_sols <- unique_solution_ct(sample_sols100)
head(unique_sols)

# Get planning unit count for each solution; range prints in console
sols_unit_ct <- solutions_unit_ct(sample_sols100)

# Find solutions with minimum unit counts
min_PU_ct <- min(sols_unit_ct$PU_ct)
# Print solutions with minimum PU counts
min_solutions <- sols_unit_ct[sols_unit_ct$PU_ct == min_PU_ct, ]
cat("Solution numbers with the minimum PU_count:\n", paste(min_solutions$solution, collapse = "\n"))

# Bring in spatial data; here we have only PU id and remove other data
# Relabel the column with the unique PU identification to "PU_num"
pu_data <- optimTFE::units_spp_suit
pu_data <- pu_data |>
  #rename(PU_num = uniqueID) |> example where PU column begins as 'uniqueID
  select(-c(2:37))
# plot(pu_data) - eastern portion of Maui Island

# Return a dataframe of unit count frequencies
PU_ct_freq <- all_solutions_freq(sols_unit_ct)

# make a distribution plot of PU_counts
plot_solutions_freq(PU_ct_freq)

```
Now we can take a look at a map of the planning unit selection frequency across all conservation footprints.

```{r Plot frequency of planning units across all footprints, echo=TRUE, fig.width=8.25, fig.height=6, fig.show='asis'}
pu_ct_freq_map(solution_output = sample_sols100 , pu_spatial_data = pu_data)
```

Next we may want to plot a single footprint. Here we will plot one with a minimum
planning unit count.
```{r Plot single footprint, fig.width=8.25, fig.height=6, fig.show='asis'}
# Get solution number from solution with smallest footprint
solution_number <- min_solutions[[1]][1]
map_sol_min <- single_solution_map(solution_number, sample_sols100, pu_data)
```

Next let's generate habitat suitability values for each species within a given footprint.  
Conservation practitioners may prefer a larger footprint than a minimum size if it
yields habitat more suited to species to be recovered.  
With OptimTFE, we can explore such tradeoffs.

We will again use the optimTFE solutions output as well as the solution number of
interest, and the metadata filepath.  
This function calculates one footprint at a time, as it could be computationally 
consuming with >10,000 footprints. (And we create them collectively as part of another evaluation tool later.)

```{r Get suitability values for input features for a given footprint, echo=TRUE}
# Habitat suitability calculation across all features, selected for or not.
# You must read in the solutions file as a data.frame; solution number is the solution to evaluate; meta_filepath is the filepath to the solutions.meta file.
 # All 0s are NAs unless you convert them.

sol_suit_values <- solution_suit_values(solution_number, sample_sols100, file.path(project_dir, "output", "solutions.meta"))
```
Next, let's get the suitability values for **selected features** that were per planning unit.  
For example, the solution output file shows 1s and 0s for each planning unit for each feature. We will calculate suitability only for the 1s (i.e, excluding species that were present, but not selected for at each given conservation footprint planning unit). In contrast, the previous calculation gave the suitability across all species that had suitability values
> 0.

The first input comes from the output of solution_suit_values. If you do not want
to use that input, your input dataframe must include the unit_id column first, and
remaining columns are the feature columns with 1s and 0s from the solution output file.

```{r Generate species suitability list for target units only}
# Calculate suitability across PUs for selected features only
sol_selected_spp_suit <- selected_spp_suit(solution_number, sample_sols100, file.path(project_dir, "output", "solutions.meta"))
```
Now let's generate some metrics about footprints so we can compare.
We will read-in .shp or .gpkg file with unit_id as the first column and the rest
have metrics of interest for selecting a footprint. For example, this dataset has 
area_km2 because units are not uniform, percent of unit within an existing conservation
reserve, percent of unit considered 'good' quality habitat, etc.

You will need to determine how to summarize your data, and provided below is an example.
```{r Setup associated metrics and create a solution summary}
# The all_sols_metrics object created will be used in the optimTFE_explorer tool.
# Read in variables that are aggregated at the unit_id level.
# unit_id must be the first column.

PU_metrics <- read_sf(system.file("extdata", "PU_metrics.gpkg", package = "optimTFE"))
# Get rid of any unneccessary columns and keep track of order/naming

# Now we will merge to get all summary data and solution info with spatial data. This could get
# big, so it may be prudent to subset based on footprint unit count or other important metrics.

# Keep unit_id and solution as columns 1 and 2, and columns for getting summary stats 
# (area, conservation lands, etc.)

sample_sols100_metrics <- left_join(PU_metrics, sample_sols100, by = c("PU_num" = "unit_id"))
# Renaming so we can pull spatial data later if desired
sample_sols100_metrics_df <- as.data.frame(sample_sols100_metrics) |>
  relocate(solution, .after = PU_num) |>
  select(-c(select_order, geom))
# Confirm no geometry or geom column

# Make a new df, summarized by solution number. Get solution-level metrics:
all_sols_metrics <- sample_sols100_metrics_df |>
  filter(!is.na(solution)) |> #some units do not occur in any solution
  group_by(solution) |>
  summarise(
    total_area_kmsq = sum(area_km2, na.rm = TRUE), # total footprint area
    good_hab_mean_pct = (sum(good_hab_kmsq, na.rm = TRUE) / sum(area_km2, na.rm 
          = TRUE)) * 100, #mean percent of footprint with 'good' habitat
    area_unfenced_mean_pct = (sum(not_fenced_kmsq, na.rm = TRUE) / sum(area_km2,
          na.rm = TRUE)) * 100, #mean percent of footprint unfenced
    area_fenced_mean_pct = (sum(fenced_kmsq, na.rm = TRUE) / sum(area_km2,
          na.rm = TRUE)) * 100,
    cons_lands_mean_pct = (sum(reserved_kmsq, na.rm = TRUE) / sum(area_km2, na.rm 
          = TRUE)) * 100,
    FB_richness_max_mean = mean(max_FB_richness, na.rm = TRUE),
    accessibility_max_mean = mean(max_accessibility, na.rm = TRUE)
  )
# Optional: Export as .csv for running the explore footprints tool later. This is the
# column structure needed as input.
write.csv(all_sols_metrics, file.path(project_dir, "output", "sample_sols100_metrics.csv"))

# Now we will calculate solutions with minimum and maximum values across each metric
# First, define which columns are metrics
sol_metrics <- names(all_sols_metrics[2:8])
# Then run metrics_top_solutions function to generate dateframe with min, max, or both
# for each metric across all solutions
max_sol_calcs <- metrics_top_solutions(all_sols_metrics, sol_metrics, summary_type = max)
head(max_sol_calcs)

min_sol_calcs <- metrics_top_solutions(all_sols_metrics, sol_metrics, summary_type = min)
```

Plot a footprint and show where it falls compared to all footprints, and the top 10%
of all footprints, for a given metric.
```{r Plot distribution of footprints across metrics compared to a single footprint, echo=FALSE, fig.width=8.25, fig.height=6, fig.show='asis'}
# The metric we are evaluating is native habitat denoted as 'good_hab_mean_pct.'
# We will use the dataframe generated above with metrics for each footprint (all_sols_metrics).

plot_my_metric <- plot_solution_metric(solution_number, all_sols_metrics, "good_hab_mean_pct", 0.9)
plot_my_metric
```
We have more advanced tools for visually exploring footprints further:  
1. **Explore_footprints** vignette for exploring metrics across all footprints; and
2. **Footprint_map** vignette for exploring target and landscape metrics of a single
footprint.

****Note:
We do not have lock-in or lock-out functions at this time. If this is desired,
one can create another species input column in the suitability file and assign values
to '1' or assign as an existing population, and set targets to meet the number of
PUs assigned in the corresponding file.
